/*jshint esversion: 6 */
const rp = require('request-promise-native');
const { Chronometer } = require('express-chrono')({ header: true });
const { URL } = require('url');
const basicUrl = require('basic-url');
const mask = require('mask-pii')();

let logger;
const buildUrlForCrossOrClient = (url, type = 'cross') => {
  const myUrl = new URL(url);
  const parsedUrl = myUrl.pathname.split('/');
  myUrl.pathname = myUrl.pathname.replace(parsedUrl[1], type);
  return myUrl.href;
};
module.exports.appStart = (_logger) => {
  logger = _logger;
};

module.exports.init = (serviceInit) => {
  if (!serviceInit || !serviceInit.requestId) {
    throw new Error('invalid request in logged promise');
  }

  return (opt) => {
    logger.info(`methodName:loggedRequestPromise callStep:started requestId:${serviceInit.requestId}`, JSON.stringify(opt, mask));
    opt = opt || {};
    opt.headers = opt.headers || {};
    opt.headers['X-Request-Id'] = serviceInit.requestId;
    opt.headers['Content-Type'] = opt.headers['Content-Type'] || 'application/json';
    opt.json = opt.json || false;
    opt.agentOptions = opt.agentOptions || { rejectUnauthorized: false };
    opt.resolveWithFullResponse = opt.resolveWithFullResponse || false;

    opt.isAuthenticated = opt.isAuthenticated || false;
    opt.isClientAuthenticated = opt.isClientAuthenticated || false;

    if (serviceInit.currentClient) {
      opt.isAuthenticated = false;
      opt.isClientAuthenticated = true;
      opt.uri = buildUrlForCrossOrClient(opt.uri, 'client');
    }

    if (opt.isAuthenticated) {
      opt.headers.authorization = serviceInit.authorization;
    } else if (opt.isClientAuthenticated) {
      opt.headers.client_key = serviceInit.clientKey;
      opt.headers.client_secret = serviceInit.clientSecret;
      opt.headers.organization_id = serviceInit.getOrganizationId(true);
      if (opt.clientUrl) {
        opt.uri = buildUrlForCrossOrClient(opt.uri, 'client');
      }
    }

    //user eger cross ile gelirse app js te serviceinite cross Options setlenir.
    //default akista bu cross optionsin, akista olusan diger requestlere de ilave edilmesi gerekir.
    //boylece yoluna cross baslamis bir user, butun sub callarinda cross ile devam etmis olur.
    //ancak bazi durumlarda user cross ile gelse bile crosssuz bir request yaratmak isteyebilir, ornegin:
    //3rd party calllarin (ornegin GDS calls) cross ile hicbir alakasi yoktur. 
    //dolayisiyla crossOptions olsa bile bu cross un setlenip yollanmamasi gerekir. (aynen token in setlenmemesi gerektigi gibi)//zaten bundan dolayi yukarda opt.isAuthenticated=>true olarak belirtilmisse token setlenmektedir.
    //ve default parametre degeri falsetur. dolayisiyla bir developer authenticated bir call yapmak isterse
    //bunu belirtmekle sorumludur 
    if (serviceInit.crossOptions && opt.isAuthenticated) {

      opt.headers.cross = serviceInit.crossOptions.cross;
      opt.crossedUrl = opt.crossedUrl == null ? true : opt.crossedUrl;
      opt.notForwardCross = opt.notForwardCross === true ? false : true;

      if (opt.crossedUrl) {
        opt.uri = buildUrlForCrossOrClient(opt.uri, 'cross');
      }

      if (!opt.notForwardCross) {
        delete opt.headers.cross;
      }
    }
    // eger organization_id varsa kendimiz replace edebiliriz
    if (opt.uri && opt.uri.indexOf('/:organization_id') > -1) {
      opt.uri = basicUrl({ url: opt.uri, params: { organization_id: serviceInit.getOrganizationId() } });
    }
    if (opt.url && opt.url.indexOf('/:organization_id') > -1) {
      opt.url = basicUrl({ url: opt.url, params: { organization_id: serviceInit.getOrganizationId() } });
    }
    const chrono = new Chronometer({ format: 'ms', suffix: true });
    chrono.start();

    return new Promise((__resolver, __rejecter) => {
      rp(opt)
        .then((value) => {
          chrono.stop();
          logger.info(`methodName:loggedRequestPromise callStep:finished requestId:${serviceInit.requestId}`, JSON.stringify(value, mask), `elapsedTime:${chrono.toString()}`);
          return __resolver(value);
        })
        .catch((err) => {
          chrono.stop();
          const msg = `methodName:loggedRequestPromise callStep:errored requestId:${serviceInit.requestId} errorName:${err.name} errorStatus:${err.status} errorMessage:${err.message} errorStack:${err.stack} elapsedTime:${chrono.toString()}`;
          if (err.error.customErrorType === 'Business') {
            logger.info(msg);
          } else {
            logger.error(msg);
          }
          logger.debug(`methodName:loggedRequestPromise requestId:${serviceInit.requestId}`, err.error);
          return __rejecter(err.error);
        });
    });
  };
};